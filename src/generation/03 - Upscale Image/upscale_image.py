#!/usr/bin/env python3
"""
Up Scaler
Takes a pre-generated 1080p image and up scales it to multiple resolutions using Real-ESRGAN
Currently generates 4K and 8K versions, but easily extensible to add more resolutions
Each resolution is generated by chaining 2x upscales from the previous result
"""

import gc
import sys
import warnings
from typing import Final
from pathlib import Path
from dataclasses import dataclass
from PIL import Image
import torch
import numpy as np
from realesrgan import RealESRGANer
from basicsr.archs.rrdbnet_arch import RRDBNet

# Suppress PIL import warnings for optional plugins
warnings.filterwarnings("ignore", message=".*failed to import.*ImagePlugin.*")

# Import our local utilities
from pipeline_utilities import authentication, generation, args, logging_utils, paths


@dataclass
class ResolutionConfig:
    """ Configuration for a specific output resolution """
    width: int
    height: int
    name: str

    @property
    def suffix(self) -> str:
        """ Derive suffix from name by adding underscore prefix """
        return f"_{self.name.lower()}"

    def __str__(self) -> str:
        return f"{self.name} ({self.width}x{self.height})"


class _DefaultProperties:
    UPSCALE_FACTOR: Final[int] = 2
    MODEL_NAME: Final[str] = "RealESRGAN_x2plus"
    EXPECTED_INPUT_WIDTH: Final[int] = 1920
    EXPECTED_INPUT_HEIGHT: Final[int] = 1080

    # Resolution configurations
    OUTPUT_RESOLUTIONS: Final[list[ResolutionConfig]] = [
        ResolutionConfig(3840, 2160, "4K"),
        ResolutionConfig(7680, 4320, "8K")
    ]


_args = args.parse_arguments("Up scales a given image to 4k")
_authentication = authentication.load_authentication_config(_args.authentication)
_config = generation.load_generation_config(_args.config)
_logger = logging_utils.setup_pipeline_logging(
    log_file=_args.log_file,
    debug=_config.data.debug
)


def _get_device() -> torch.device:
    """ Get the best available device for processing """
    if torch.backends.mps.is_available():
        return torch.device("mps")
    if torch.cuda.is_available():
        return torch.device("cuda")
    return torch.device("cpu")


def _clear_memory() -> None:
    """ Clears system and MPS memory """
    gc.collect()
    if torch.backends.mps.is_available():
        # MPS cache clearing is only available in newer PyTorch versions
        if hasattr(torch, 'mps') and hasattr(torch.mps, 'empty_cache'):
            torch.mps.empty_cache()


def _validate_input_resolution(image: Image.Image) -> None:
    """ Validates that the input image is 1080p (1920x1080) """

    if image.width != _DefaultProperties.EXPECTED_INPUT_WIDTH or image.height != _DefaultProperties.EXPECTED_INPUT_HEIGHT:
        raise ValueError(
            f"Input image resolution is {image.width}x{image.height}, "
            f"but expected {_DefaultProperties.EXPECTED_INPUT_WIDTH}x{_DefaultProperties.EXPECTED_INPUT_HEIGHT} (1080p)"
        )
    _logger.info("Input resolution validation passed: %dx%d (1080p)", image.width, image.height)


def _validate_output_resolution(image: Image.Image, expected_width: int, expected_height: int, resolution_name: str) -> None:
    """ Validates that the output image has the expected resolution """

    if image.width != expected_width or image.height != expected_height:
        raise ValueError(
            f"Output image resolution is {image.width}x{image.height}, "
            f"but expected {expected_width}x{expected_height} ({resolution_name})"
        )
    _logger.info("Output resolution validation passed: %dx%d (%s)", image.width, image.height, resolution_name)


def _upscale_image() -> list[str]:
    """ Up scales a given image to multiple resolutions using Real-ESRGAN """

    # Define input and output paths
    source_image_path = (
        Path(_args.output) /
        paths.Paths.RESULT /
        paths.Paths.TEMP /
        paths.Paths.OUTPUT_02
    )
    # Validate input image exists
    if not source_image_path.is_file():
        raise FileNotFoundError(f"Required source image not found: {source_image_path}")

    _logger.header("Setting up Real-ESRGAN")

    # Get device and setup Real-ESRGAN
    device = _get_device()

    # Create the Real-ESRGAN model
    model = RRDBNet(num_in_ch=3, num_out_ch=3, num_feat=64, num_block=23, num_grow_ch=32, scale=2)

    # Initialize the upscaler
    upsampler = RealESRGANer(
        scale=_DefaultProperties.UPSCALE_FACTOR,
        model_path='../../../models/RealESRGAN_x2plus.pth',  # Download model automatically
        model=model,
        tile=0,  # No tiling for better quality
        tile_pad=10,
        pre_pad=0,
        half=False,  # Keep full precision for better quality
        gpu_id=None if str(device) == 'mps' else 0,  # Handle MPS device
        device=device
    )

    _logger.info("Loading source image: %s", source_image_path)
    source_image = Image.open(source_image_path).convert("RGB")

    # Validate input resolution is 1080p
    _validate_input_resolution(source_image)

    # Convert PIL image to numpy array for Real-ESRGAN
    current_img_array = np.array(source_image)
    output_paths = []

    # Process each resolution in sequence
    for config in _DefaultProperties.OUTPUT_RESOLUTIONS:
        _logger.info("Starting %s upscaling process (2x upscale)", config.name)

        with torch.no_grad():
            upscaled_array, _ = upsampler.enhance(current_img_array, outscale=_DefaultProperties.UPSCALE_FACTOR)

        # Convert back to PIL Image
        upscaled_image = Image.fromarray(upscaled_array)

        # Validate output resolution
        _validate_output_resolution(upscaled_image, config.width, config.height, config.name)

        # Save the upscaled image
        base_filename = Path(paths.Paths.OUTPUT_03).stem  # Get filename without extension
        output_path = (
            Path(_args.output) /
            paths.Paths.RESULT /
            paths.Paths.TEMP /
            f"{base_filename}{config.suffix}.png"
        )
        output_path.parent.mkdir(parents=True, exist_ok=True)
        upscaled_image.save(output_path)
        output_paths.append(str(output_path))

        _logger.info("%s upscaling completed successfully: %s", config.name, output_path)

        # Use this result as input for the next iteration (for chained upscaling)
        current_img_array = np.array(upscaled_image)

    # Clean up memory
    del upsampler
    del model
    _clear_memory()

    _logger.info("All upscaling operations completed successfully")
    return output_paths


def main() -> None:
    """ Main entry point """
    try:
        output_paths = _upscale_image()
        for i, path in enumerate(output_paths):
            config = _DefaultProperties.OUTPUT_RESOLUTIONS[i]
            _logger.info("Success! %s image up scaled: %s", config.name, path)
    except (ImportError, OSError, RuntimeError, ValueError) as e:
        _logger.error("%s: %s", type(e).__name__, e)
        sys.exit(1)


if __name__ == "__main__":
    main()
